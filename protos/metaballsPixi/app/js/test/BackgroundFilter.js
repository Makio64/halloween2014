var BackgroundFilter,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

BackgroundFilter = (function(_super) {
  __extends(BackgroundFilter, _super);

  function BackgroundFilter() {
    BackgroundFilter.__super__.constructor.call(this);
    this.passes = [this];
    this.uniforms = {
      time: {
        type: "1f",
        value: 0.0
      }
    };
    this.fragmentSrc = ['precision lowp float;', 'varying vec2 vTextureCoord;', 'uniform float time;', 'float snoise(vec3 uv, float res)    // by trisomie21 & thx shadertoy', '{', 'const vec3 s = vec3(1e0, 1e2, 1e4);', 'uv *= res;', 'vec3 uv0 = floor(mod(uv, res))*s;', 'vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;', 'vec3 f = fract(uv); f = f*f*(3.0-2.0*f);', 'vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,', 'uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);', 'vec4 r = fract(sin(v*1e-3)*1e5);', 'float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);', 'r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);', 'float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);', 'return mix(r0, r1, f.z)*2.-1.;', '}', 'void main(void) {', '//bool isEqual = mod(floor(vTextureCoord.x*1025.),2.)==0.;', 'vec2 center = vec2(.5,.33);', 'float angle = atan(center.y-vTextureCoord.y,center.x-vTextureCoord.x)*3.14*4.+time;', 'float rand = snoise(vec3(angle,angle,0.),3.14*2. );', 'float dist = distance(vTextureCoord, center);', 'vec3 color = vec3(rand*.3*(1.-dist));', 'color = color*dist*1.5;', 'gl_FragColor =  vec4( color, 1. );', '}'];
  }

  return BackgroundFilter;

})(PIXI.AbstractFilter);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3QvQmFja2dyb3VuZEZpbHRlci5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsSUFBQSxnQkFBQTtFQUFBO2lTQUFBOztBQUFBO0FBRUkscUNBQUEsQ0FBQTs7QUFBWSxFQUFBLDBCQUFBLEdBQUE7QUFDUixJQUFBLGdEQUFBLENBQUEsQ0FBQTtBQUFBLElBQ0EsSUFBSSxDQUFDLE1BQUwsR0FBYyxDQUFDLElBQUQsQ0FEZCxDQUFBO0FBQUEsSUFHQSxJQUFJLENBQUMsUUFBTCxHQUFnQjtBQUFBLE1BQ1osSUFBQSxFQUFhO0FBQUEsUUFBRSxJQUFBLEVBQU0sSUFBUjtBQUFBLFFBQWMsS0FBQSxFQUFPLEdBQXJCO09BREQ7S0FIaEIsQ0FBQTtBQUFBLElBT0EsSUFBSSxDQUFDLFdBQUwsR0FBbUIsQ0FFZix1QkFGZSxFQUdmLDZCQUhlLEVBSWYscUJBSmUsRUFNZixzRUFOZSxFQU9mLEdBUGUsRUFRWCxxQ0FSVyxFQVNYLFlBVFcsRUFVWCxtQ0FWVyxFQVdYLDRDQVhXLEVBWVgsMENBWlcsRUFhWCxxREFiVyxFQWNYLHdDQWRXLEVBZVgsa0NBZlcsRUFnQlgsOERBaEJXLEVBaUJYLCtDQWpCVyxFQWtCWCw4REFsQlcsRUFtQlgsZ0NBbkJXLEVBb0JmLEdBcEJlLEVBc0JmLG1CQXRCZSxFQXVCWCw0REF2QlcsRUF3QlgsNkJBeEJXLEVBeUJYLHFGQXpCVyxFQTBCWCxxREExQlcsRUEyQlgsK0NBM0JXLEVBNEJYLHVDQTVCVyxFQTZCWCx5QkE3QlcsRUE4Qlgsb0NBOUJXLEVBK0JmLEdBL0JlLENBUG5CLENBRFE7RUFBQSxDQUFaOzswQkFBQTs7R0FGMkIsSUFBSSxDQUFDLGVBQXBDLENBQUEiLCJmaWxlIjoidGVzdC9CYWNrZ3JvdW5kRmlsdGVyLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIiwic291cmNlc0NvbnRlbnQiOlsiIyAvKipcbiMgICogQGF1dGhvciBEYXZpZCBSb25haSBodHRwOi8vbWFraW9wb2xpcy5jb20vIEBNYWtpbzY0XG4jICAqL1xuXG4jIC8qKlxuIyAgKiBAY2xhc3MgQmFja2dyb3VuZEZpbHRlclxuIyAgKiBAY29udHJ1Y3RvclxuIyAgKi9cbmNsYXNzIEJhY2tncm91bmRGaWx0ZXIgZXh0ZW5kcyBQSVhJLkFic3RyYWN0RmlsdGVyXG5cbiAgICBjb25zdHJ1Y3RvcjooKS0+XG4gICAgICAgIHN1cGVyKCkgXG4gICAgICAgIHRoaXMucGFzc2VzID0gW3RoaXNdO1xuXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB7XG4gICAgICAgICAgICB0aW1lOiAgICAgICAgeyB0eXBlOiBcIjFmXCIsIHZhbHVlOiAwLjAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgICAgXG4gICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBbXG5cbiAgICAgICAgICAgICdwcmVjaXNpb24gbG93cCBmbG9hdDsnLFxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCB0aW1lOycsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICdmbG9hdCBzbm9pc2UodmVjMyB1diwgZmxvYXQgcmVzKSAgICAvLyBieSB0cmlzb21pZTIxICYgdGh4IHNoYWRlcnRveSdcbiAgICAgICAgICAgICd7JyxcbiAgICAgICAgICAgICAgICAnY29uc3QgdmVjMyBzID0gdmVjMygxZTAsIDFlMiwgMWU0KTsnLFxuICAgICAgICAgICAgICAgICd1diAqPSByZXM7JyxcbiAgICAgICAgICAgICAgICAndmVjMyB1djAgPSBmbG9vcihtb2QodXYsIHJlcykpKnM7JyxcbiAgICAgICAgICAgICAgICAndmVjMyB1djEgPSBmbG9vcihtb2QodXYrdmVjMygxLiksIHJlcykpKnM7JyxcbiAgICAgICAgICAgICAgICAndmVjMyBmID0gZnJhY3QodXYpOyBmID0gZipmKigzLjAtMi4wKmYpOycsXG4gICAgICAgICAgICAgICAgJ3ZlYzQgdiA9IHZlYzQodXYwLngrdXYwLnkrdXYwLnosIHV2MS54K3V2MC55K3V2MC56LCcsXG4gICAgICAgICAgICAgICAgJ3V2MC54K3V2MS55K3V2MC56LCB1djEueCt1djEueSt1djAueik7JyxcbiAgICAgICAgICAgICAgICAndmVjNCByID0gZnJhY3Qoc2luKHYqMWUtMykqMWU1KTsnLFxuICAgICAgICAgICAgICAgICdmbG9hdCByMCA9IG1peChtaXgoci54LCByLnksIGYueCksIG1peChyLnosIHIudywgZi54KSwgZi55KTsnLFxuICAgICAgICAgICAgICAgICdyID0gZnJhY3Qoc2luKCh2ICsgdXYxLnogLSB1djAueikqMWUtMykqMWU1KTsnLFxuICAgICAgICAgICAgICAgICdmbG9hdCByMSA9IG1peChtaXgoci54LCByLnksIGYueCksIG1peChyLnosIHIudywgZi54KSwgZi55KTsnLFxuICAgICAgICAgICAgICAgICdyZXR1cm4gbWl4KHIwLCByMSwgZi56KSoyLi0xLjsnLFxuICAgICAgICAgICAgJ30nLFxuXG4gICAgICAgICAgICAndm9pZCBtYWluKHZvaWQpIHsnLFxuICAgICAgICAgICAgICAgICcvL2Jvb2wgaXNFcXVhbCA9IG1vZChmbG9vcih2VGV4dHVyZUNvb3JkLngqMTAyNS4pLDIuKT09MC47JyxcbiAgICAgICAgICAgICAgICAndmVjMiBjZW50ZXIgPSB2ZWMyKC41LC4zMyk7J1xuICAgICAgICAgICAgICAgICdmbG9hdCBhbmdsZSA9IGF0YW4oY2VudGVyLnktdlRleHR1cmVDb29yZC55LGNlbnRlci54LXZUZXh0dXJlQ29vcmQueCkqMy4xNCo0Lit0aW1lOydcbiAgICAgICAgICAgICAgICAnZmxvYXQgcmFuZCA9IHNub2lzZSh2ZWMzKGFuZ2xlLGFuZ2xlLDAuKSwzLjE0KjIuICk7J1xuICAgICAgICAgICAgICAgICdmbG9hdCBkaXN0ID0gZGlzdGFuY2UodlRleHR1cmVDb29yZCwgY2VudGVyKTsnXG4gICAgICAgICAgICAgICAgJ3ZlYzMgY29sb3IgPSB2ZWMzKHJhbmQqLjMqKDEuLWRpc3QpKTsnLFxuICAgICAgICAgICAgICAgICdjb2xvciA9IGNvbG9yKmRpc3QqMS41OycsXG4gICAgICAgICAgICAgICAgJ2dsX0ZyYWdDb2xvciA9ICB2ZWM0KCBjb2xvciwgMS4gKTsnLFxuICAgICAgICAgICAgJ30nXG4gICAgICAgIF07Il19